/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Egor Kulikov
 */




#include <bits/stdc++.h>

using namespace std;

#define all(v) (v).begin(), (v).end()

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;

const double PI = atan(1) * 4;

template<typename T>
T minim(T &was, T cand) {
    return was = min(was, cand);
}

template<typename T>
T maxim(T &was, T cand) {
    return was = max(was, cand);
}

template<typename T, typename U>
void decreaseByOne(vector<pair<T, U> > &v) {
    for (auto &p : v) {
        p.first--;
        p.second--;
    }
}

void decreaseByOne() {}

template<typename T, class...Vs>
void decreaseByOne(vector<T> &arr, Vs &...vs) {
    int n = arr.size();
    for (int i = 0; i < n; ++i) {
        arr[i]--;
    }
    decreaseByOne(vs...);
}


template<typename D>
D dPower(D base, ll exponent) {
    if (exponent < 0) {
        return dPower(1 / base, -exponent);
    }
    if (exponent == 0) {
        return 1;
    }
    if ((exponent & 1) == 1) {
        return dPower(base, exponent - 1) * base;
    } else {
        D res = dPower(base, exponent >> 1);
        return res * res;
    }
}


inline bool isWhitespace(int c) {
    return isspace(c) || c == EOF;
}

class Input {
private:
    istream &in;
    bool exhausted = false;

    inline int get() {
        if (exhausted) {
            throw "Input exhausted";
        }
        int c = in.get();
        if (c == EOF) {
            exhausted = true;
        }
        return c;
    }

    template<typename T>
    inline T readInteger() {
        skipWhitespace();
        int c = get();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = get();
        }
        T res = 0;
        do {
            if (!isdigit(c)) {
                throw "Number format error";
            }
            res *= 10;
            res += c - '0';
            c = get();
        } while (!isWhitespace(c));
        return res * sgn;
    }

    void initArrays(int n) {}

    template<typename T, class...Vs>
    void initArrays(int n, vector<T> &arr, Vs &...vs) {
        arr.resize(n);
        initArrays(n, vs...);
    }

    void readImpl(int i) {}

    template<typename T, class...Vs>
    void readImpl(int i, vector<T> &arr, Vs &...vs) {
        arr[i] = readType<T>();
        readImpl(i, vs...);
    }

public:
    Input(istream &in) : in(in) {};

    inline void skipWhitespace() {
        int c;
        while (isWhitespace(c = in.peek()) && c != EOF) {
            in.get();
        }
        if (c == EOF) {
            exhausted = true;
        }
    }

    inline int readInt() {
        return readInteger<int>();
    }

    ll readLong() {
        return readInteger<ll>();
    }

    string readString() {
        skipWhitespace();
        int c = get();
        if (c == EOF) {
            throw "Input exhausted";
        }
        vector<char> res;
        do {
            res.push_back(c);
        } while (!isWhitespace(c = get()));
        return string(all(res));
    }

    vector<int> readIntArray(int size) {
        return readArray<int>(size);
    }

    template<typename T>
    T readType() {
        throw "Operation not supported";
    }

    template<typename U, typename V>
    pair<U, V> readType() {
        U first = readType<U>();
        V second = readType<V>();
        return make_pair(first, second);
    }

    template<typename T>
    vector<T> readArray(int n) {
        vector<T> res;
        res.reserve(n);
        for (int i = 0; i < n; i++) {
            res.push_back(readType<T>());
        }
        return res;
    }


    template<class...Vs>
    void readArrays(int n, Vs &...vs) {
        initArrays(n, vs...);
        for (int i = 0; i < n; i++) {
            readImpl(i, vs...);
        }
    }

    template<typename U, typename V>
    vector<pair<U, V> > readArray(int n) {
        vector<pair<U, V> > res;
        res.reserve(n);
        for (int i = 0; i < n; i++) {
            res.push_back(readType<U, V>());
        }
        return res;
    }

    template<typename T>
    vector<vector<T> > readTable(int rows, int cols) {
        vector<vector<T> > result;
        result.reserve(rows);
        for (int i = 0; i < rows; ++i) {
            result.push_back(readArray<T>(cols));
        }
        return result;
    }

    string readLine() {
//        skipWhitespace();
        int c = get();
        if (c == EOF) {
            throw "Input exhausted";
        }
        int length = 0;
        vector<char> res;
        do {
            res.push_back(c);
            if (!isWhitespace(c)) {
                length = res.size();
            }
            c = get();
        } while (c != '\n' && c != '\r' && c != EOF);
        return string(res.begin(), res.begin() + length);
    }

    double readDouble() {
        skipWhitespace();
        int c = get();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = get();
        }
        double res = 0;
        do {
            if (tolower(c) == 'e') {
                return sgn * res * dPower(10, readInt());
            }
            if (!isdigit(c)) {
                throw "Number format error";
            }
            res *= 10;
            res += c - '0';
            c = get();
        } while (!isWhitespace(c) && c != '.');
        if (c == '.') {
            double add = 0;
            int length = 0;
            c = get();
            do {
                if (tolower(c) == 'e') {
                    return sgn * (res + add * dPower(10, -length)) * dPower(10, readInt());
                }
                if (!isdigit(c)) {
                    throw "Number format error";
                }
                add *= 10;
                add += c - '0';
                length++;
                c = get();
            } while (!isWhitespace(c));
            res += add * dPower(10, -length);
        }
        return res * sgn;
    }

    char readChar() {
        skipWhitespace();
        int c = get();
        if (c == EOF) {
            throw "Input exhausted";
        }
        return c;
    }

    bool isExhausted() { return exhausted; }
};

template<>
double Input::readType() {
    return readDouble();
}

template<>
int Input::readType() {
    return readInt();
}

template<>
ll Input::readType() {
    return readLong();
}

template<>
char Input::readType() {
    return readChar();
}

template<>
string Input::readType() {
    return readString();
}


class Output {
private:
    ostream &out;

    template<typename T>
    void printSingle(const T &value) {
        out << value;
    }

    template<typename T>
    void printSingle(const vector<T> &array) {
        size_t n = array.size();
        for (int i = 0; i < n; ++i) {
            out << array[i];
            if (i + 1 != n) {
                out << ' ';
            }
        }
    }

    template<typename T, typename U>
    void printSingle(const pair<T, U> &value) {
        out << value.first << ' ' << value.second;
    }

public:
    Output(ostream &out) : out(out) {
        out << fixed << setprecision(12);
    }

    void print() {}

    template<typename T, typename...Targs>
    void print(const T &first, const Targs... args) {
        printSingle(first);
        if (sizeof...(args) != 0) {
            out << ' ';
            print(args...);
        }
    }

    template<typename...Targs>
    void printLine(const Targs... args) {
        print(args...);
        out << '\n';
    }

    void flush() {
        out.flush();
    }
};


class NumberIterator : iterator<forward_iterator_tag, int> {
public:
    int v;

    NumberIterator(int v) : v(v) {}

    operator int &() { return v; }

    int operator*() { return v; }
};

class Range : pii {
public:
    Range(int begin, int end) : pii(begin, max(begin, end)) {}

    Range(int n) : pii(0, max(0, n)) {}

    NumberIterator begin() {
        return first;
    }

    NumberIterator end() {
        return second;
    }
};


const int MOD7 = 1000000007;
const int MOD9 = 1000000009;
const int MODF = 998244353;

int mod = MOD7;

template<typename T>
T gcd(T a, T b, T &x, T &y) {
    if (a == 0) {
        x = 0;
        y = 1;
        return b;
    }
    int d = gcd(b % a, a, y, x);
    x -= (b / a) * y;
    return d;
}

class modint {
public:
    int n;

    modint() : n(0) {}

    modint(ll n) {
        if (n >= 0 && n < mod) {
            this->n = n;
            return;
        }
        n %= mod;
        if (n < 0) {
            n += mod;
        }
        this->n = n;
    }

    modint &operator+=(const modint &other) {
        n += other.n;
        if (n >= mod) {
            n -= mod;
        }
        return *this;
    }

    modint &operator-=(const modint &other) {
        n -= other.n;
        if (n < 0) {
            n += mod;
        }
        return *this;
    }

    modint &operator*=(const modint &other) {
        n = ll(n) * other.n % mod;
        return *this;
    }

    modint operator-() {
        if (n == 0) {
            return 0;
        }
        return modint(mod - n);
    }

    modint inverse() {
        ll x, y;
        gcd(ll(n), ll(mod), x, y);
        return x;
    }
};

modint operator+(const modint &a, const modint &b) {
    return modint(a) += b;
}

modint operator-(const modint &a, const modint &b) {
    return modint(a) -= b;
}

modint operator*(const modint &a, const modint &b) {
    return modint(a) *= b;
}

ostream &operator<<(ostream &out, const modint &val) {
    return out << val.n;
}

bool operator==(const modint &a, const modint &b) {
    return a.n == b.n;
}

bool operator!=(const modint &a, const modint &b) {
    return a.n != b.n;
}


template<typename T>
T gcd(T a, T b) {
    a = abs(a);
    b = abs(b);
    while (b != 0) {
        a = a % b;
        swap(a, b);
    }
    return a;
}

template<typename T>
T lcm(T a, T b) {
    return a / gcd(a, b) * b;
}

template<typename T>
T power(const T &a, ll b) {
    if (b == 0) {
        return 1;
    }
    if ((b & 1) == 0) {
        T res = power(a, b >> 1);
        return res * res;
    } else {
        return power(a, b - 1) * a;
    }
}

template<typename T>
vector<T> generateFactorial(int length) {
    vector<T> result(length);
    if (length > 0) {
        result[0] = 1;
    }
    for (int i = 1; i < length; i++) {
        result[i] = result[i - 1] * i;
    }
    return result;
}

template<typename T>
vector<T> generateReverse(int length) {
    vector<T> result(length);
    if (length > 1) {
        result[1] = 1;
    }
    for (int i = 2; i < length; i++) {
        result[i] = -(mod / i) * result[mod % i];
    }
    return result;
}

template<typename T>
vector<T> generatePowers(T base, int length) {
    vector<T> result(length);
    if (length > 0) {
        result[0] = 1;
    }
    for (int i = 1; i < length; i++) {
        result[i] = result[i - 1] * base;
    }
    return result;
}

template<typename T>
vector<T> generateReverseFactorial(int length) {
    auto result = generateReverse<T>(length);
    if (length > 0) {
        result[0] = 1;
    }
    for (int i = 1; i < length; i++) {
        result[i] *= result[i - 1];
    }
    return result;
}

template<typename T>
class Combinations {
private:
    vector<T> fact;
    vector<T> revFactorial;

public:
    Combinations(int length) {
        fact = generateFactorial<T>(length);
        revFactorial = generateReverseFactorial<T>(length);
    }

public:
    T c(int n, int k) {
        if (k < 0 || k > n) {
            return 0;
        }
        return fact[n] * revFactorial[k] * revFactorial[n - k];
    }

    T factorial(int n) {
        return fact[n];
    }

    T reverseFactorial(int n) {
        return revFactorial[n];
    }
};


namespace prime_fft {
    bool init = false;
    modint root;
    modint reverseRoot;
    int rootPower;
    vector<modint> aa;
    vector<modint> bb;
}

void initPrimeFFT() {
    if (prime_fft::init) {
        return;
    }
    prime_fft::init = true;
    prime_fft::rootPower = 1;
    int pw = 0;
    while ((mod - 1) % (2 * prime_fft::rootPower) == 0) {
        prime_fft::rootPower *= 2;
        pw++;
    }
    for (int i = 2;; i++) {
        mod--;
        int exp = power(modint(2), pw - 1).n;
        int next = (exp * 2) % mod;
        mod++;
        if (power(modint(i), exp).n != 1 && power(modint(i), next).n == 1) {
            prime_fft::root = i;
            prime_fft::reverseRoot = prime_fft::root.inverse();
            break;
        }
    }
}

namespace prime_fft {
    void primeFFT(vector<modint> &array, bool invert, int n) {
        for (int i = 1, j = 0; i < n; ++i) {
            int bit = n >> 1;
            for (; j >= bit; bit >>= 1) {
                j -= bit;
            }
            j += bit;
            if (i < j) {
                swap(array[i], array[j]);
            }
        }

        for (int len = 2; len <= n; len <<= 1) {
            modint wlen = invert ? reverseRoot : root;
            for (int i = len; i < rootPower; i <<= 1) {
                wlen *= wlen;
            }
            int half = len >> 1;
            for (int i = 0; i < n; i += len) {
                modint w = 1;
                for (int j = 0; j < half; ++j) {
                    modint u = array[i + j], v = array[i + j + half] * w;
                    array[i + j] = u + v;
                    array[i + j + half] = u - v;
                    w *= wlen;
                }
            }
        }
        if (invert) {
            modint reverseSize = modint(n).inverse();
            for (int i = 0; i < n; ++i) {
                array[i] *= reverseSize;
            }
        }
    }

}

template<typename It>
void multiply(const It fBegin, const It fEnd, const It sBegin, const It sEnd, It res) {
    unsigned long fLen = fEnd - fBegin;
    unsigned long sLen = sEnd - sBegin;
    int resLen = fLen + sLen - 1;
    if (resLen <= 100) {
        fill(res, res + resLen, 0);
        for (int i = 0; i < fLen; i++) {
            for (int j = 0; j < sLen; j++) {
                res[i + j] += fBegin[i] * sBegin[j];
            }
        }
        return;
    }
    int resultSize = 1;
    while (resultSize < resLen) {
        resultSize *= 2;
    }
    vector<modint> &aa = prime_fft::aa;
    vector<modint> &bb = prime_fft::bb;
    if (aa.size() < resultSize) {
        aa.resize(resultSize);
        bb.resize(resultSize);
    }
    fill(aa.begin() + fLen, aa.begin() + resultSize, modint(0));
    fill(bb.begin() + sLen, bb.begin() + resultSize, modint(0));
    copy(fBegin, fEnd, aa.begin());
    copy(sBegin, sEnd, bb.begin());
    prime_fft::primeFFT(aa, false, resultSize);
    if (equal(fBegin, fEnd, sBegin, sEnd)) {
        copy(all(aa), bb.begin());
    } else {
        prime_fft::primeFFT(bb, false, resultSize);
    }
    for (int i = 0; i < resultSize; i++) {
        aa[i] *= bb[i];
    }
    prime_fft::primeFFT(aa, true, resultSize);
    for (int i = 0; i < resLen; i++) {
        res[i] = aa[i];
    }
}

vector<modint> multiply(vector<modint> &first, vector<modint> &second) {
    auto len = first.size() + second.size() - 1;
    vector<modint> res(len);
    multiply(all(first), all(second), res.begin());
    return res;
}


template<typename T>
inline void unique(vector<T> &v) {
    v.resize(unique(all(v)) - v.begin());
}

vi createOrder(int n) {
    vi order(n);
    for (int i = 0; i < n; i++) {
        order[i] = i;
    }
    return order;
}

template<typename T>
inline vector<vector<T> > makeArray(int a, int b, T init) {
    return vector<vector<T> >(a, vector<T>(b, init));
}

template<typename T>
inline vector<vector<vector<T> > > makeArray(int a, int b, int c, T init) {
    return vector<vector<vector<T> > >(a, makeArray<T>(b, c, init));
}

template<typename T, typename Iterator>
inline void addAll(vector<T> &v, Iterator begin, Iterator end) {
    v.insert(v.end(), begin, end);
}

vi getQty(const vi &arr, int length) {
    vi res(length);
    for (int i : arr) {
        res[i]++;
    }
    return res;
}

vi getQty(const vi &arr) {
    return getQty(arr, *max_element(all(arr)) + 1);
}

template<typename T>
void collect(vector<T> &all) {}

template<typename T, class ...Vs>
void collect(vector<T> &all, vector<T> &a, Vs &...vs) {
    addAll(all, all(a));
    collect(all, vs...);
}

void replace(const vi &all) {}

template<class ...Vs>
void replace(const vi &all, vi &a, Vs &...vs) {
    for (int &i : a) {
        i = lower_bound(all(all), i) - all.begin();
    }
    replace(all, vs...);
}

template<class ...Vs>
vi compress(Vs &...vs) {
    vi vals;
    collect(vals, vs...);
    sort(all(vals));
    unique(vals);
    replace(vals, vs...);
    return vals;
}

//#pragma comment(linker, "/STACK:200000000")

class BinomialFever {
public:
    void solve(istream &inp, ostream &outp) {
        Input in(inp);
        Output out(outp);

        mod = MODF;
        initPrimeFFT();
        prime_fft::aa.resize(2000000);
        prime_fft::bb.resize(2000000);

        int n = in.readInt();
        modint p = in.readInt();
        int r = in.readInt();
        auto work = makeArray(2, 2 * r, modint(0));
        function<void(int, int, int)> build = [&](int from, int to, int side) {
            if (from + 1 == to) {
                work[side][2 * from] = -from;
                work[side][2 * from + 1] = 1;
                return;
            }
            int mid = (from + to) / 2;
            build(from, mid, 1 - side);
            build(mid, to, 1 - side);
            multiply(work[1 - side].begin() + (2 * from), work[1 - side].begin() + (from + mid + 1),
                     work[1 - side].begin() + (2 * mid), work[1 - side].begin() + (mid + to + 1),
                     work[side].begin() + (2 * from));
        };
#ifdef LOCAL
        ll time = clock();
#endif
        build(0, r, 0);
#ifdef LOCAL
        cerr << "built " << clock() - time << endl;
#endif
        vector<modint> &poly = work[0];
        modint answer = 0;
        function<modint(modint, modint &, int)> sump = [&](modint base, modint &power, int exp) -> modint {
            if (exp == 0) {
                power = 1;
                return 0;
            }
            if ((exp & 1) == 0) {
                auto val = sump(base, power, exp >> 1);
                auto res = val * (1 + power);
                power *= power;
                return res;
            } else {
                auto val = sump(base, power, exp - 1);
                power *= base;
                return val * base + 1;
            }
        };
        modint pw = 1;
        modint temp = 0;
        for (int i : Range(r + 1)) {
            answer += sump(pw, temp, n + 1) * poly[i];
            pw *= p;
        }
        modint fact = 1;
        for (int i = 2; i <= r; i++) {
            fact *= i;
        }
        fact = power(fact, mod - 2);
        answer *= fact;
        out.printLine(answer);
    }
};


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    BinomialFever solver;
    std::istream &in(std::cin);
    std::ostream &out(std::cout);
    int n;
    in >> n;
    for (int i = 0; i < n; ++i) {
        solver.solve(in, out);
    }

    return 0;
}
