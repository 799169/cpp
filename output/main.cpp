/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Egor Kulikov
 */

#include <iostream>
#include <fstream>

#ifndef CPP_INPUT_H
#define CPP_INPUT_H

#ifndef CPP_GENERAL_H
#define CPP_GENERAL_H

#include <bits/stdc++.h>

using namespace std;

#define all(v) (v).begin(), (v).end()

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;

const double PI = atan(1) * 4;

const int DX_KNIGHT[] = {2, 1, -1, -2, -2, -1, 1, 2};
const int DY_KNIGHT[] = {1, 2, 2, 1, -1, -2, -2, -1};
const int DX4[] = {1, 0, -1, 0};
const int DY4[] = {0, 1, 0, -1};
const int DX8[] = {1, 1, 1, 0, -1, -1, -1, 0};
const int DY8[] = {-1, 0, 1, 1, 1, 0, -1, -1};

template <typename T>
T minim(T& was, T cand) {
    return was = min(was, cand);
}

template <typename T>
T maxim(T& was, T cand) {
    return was = max(was, cand);
}

bool isValidCell(int r, int c, int n, int m) {
    return r >= 0 && c >= 0 && r < n && c < m;
}

template <typename T, typename U>
void decreaseByOne(vector<pair<T, U> >& v) {
    for (auto& p : v) {
        p.first--;
        p.second--;
    }
}

void decreaseByOne() {}

template <typename T, class...Vs>
void decreaseByOne(vector<T>& arr, Vs&...vs) {
    int n = arr.size();
    for (int i = 0; i < n; ++i) {
        arr[i]--;
    }
    decreaseByOne(vs...);
}

inline bool isSubset(int set, int subSet) {
    return (set & subSet) == subSet;
}

#endif


inline bool isWhitespace(int c) {
    return isspace(c) || c == EOF;
}

class Input {
public:
    enum ErrorType {
        OK,
        END_OF_FILE,
        UNEXPECTED_SYMBOL,
        INVALID_CALL
    };

private:
    istream &in;
    bool exhausted = false;
    ErrorType error = OK;

    inline int get() {
        int result = in.get();
        if (result == EOF) {
            exhausted = true;
        }
        return result;
    }

    template<typename T>
    T readInteger() {
        error = OK;
        int c = skipWhitespace();
        if (error != OK) {
            return 0;
        }
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = get();
        }
        T res = 0;
        do {
            if (!isdigit(c)) {
                error = UNEXPECTED_SYMBOL;
                return 0;
            }
            res *= 10;
            res += c - '0';
            c = get();
        } while (!isWhitespace(c));
        return res * sgn;
    }

    inline int skipWhitespace() {
        int c;
        do {
            c = get();
            if (exhausted) {
                error = END_OF_FILE;
                return c;
            }
        } while (isWhitespace(c));
        return c;
    }

    void initArrays(int n) {}

    template <typename T, class...Vs>
    void initArrays(int n, vector<T>& arr, Vs&...vs) {
        arr.resize(n);
        initArrays(n, vs...);
    }

    void readImpl(int i) {}

    template <typename T, class...Vs>
    void readImpl(int i, vector<T>& arr, Vs&...vs) {
        arr[i] = readType<T>();
        readImpl(i, vs...);
    }

public:
    Input(istream &in) : in(in) {};

    int readInt();

    ll readLong();

    string readString();

    vector<int> readIntArray(int size) {
        return readArray<int>(size);
    }

    template<typename T>
    T readType() {
        error = INVALID_CALL;
        return nullptr;
    }

    template<typename U, typename V>
    pair<U, V> readType() {
        U first = readType<U>();
        V second = readType<V>();
        return make_pair(first, second);
    }

    template<typename T>
    vector<T> readArray(int size) {
        vector<T> res;
        res.reserve(size);
        for (int i = 0; i < size; i++) {
            res.push_back(readType<T>());
            if (error != OK) {
                res.clear();
                return res;
            }
        }
        return res;
    }



    template <class...Vs>
    void readArrays(int n, Vs&...vs) {
        initArrays(n, vs...);
        for (int i = 0; i < n; i++) {
            readImpl(i, vs...);
        }
    }

    template<typename U, typename V>
    vector<pair<U, V> > readArray(int size) {
        vector<pair<U, V> > res;
        res.reserve(size);
        for (int i = 0; i < size; i++) {
            res.push_back(readType<U, V>());
            if (error != OK) {
                res.clear();
                return res;
            }
        }
        return res;
    }

    template<typename T>
    vector<vector<T> > readTable(int rows, int cols) {
        vector<vector<T> > result;
        result.reserve(rows);
        for (int i = 0; i < rows; ++i) {
            result.push_back(readArray<T>(cols));
        }
        return result;
    }

    string readLine() {
        error = OK;
        int c = skipWhitespace();
        if (error != OK) {
            return "";
        }
        int length = 0;
        vector<char> res;
        do {
            if (error != OK) {
                return "";
            }
            res.push_back(c);
            if (!isWhitespace(c)) {
                length = res.size();
            }
            c = get();
        } while (c != '\n' && c != '\r' && c != EOF);
        return string(res.begin(), res.begin() + length);
    }

    double readDouble();

    bool isExhausted() { return exhausted; }
};

template<>
double Input::readType() {
    error = OK;
    int c = skipWhitespace();
    if (error != OK) {
        return 0;
    }
    int sgn = 1;
    if (c == '-') {
        sgn = -1;
        c = get();
    }
    double res = 0;
    do {
        if (!isdigit(c)) {
            error = UNEXPECTED_SYMBOL;
            return 0;
        }
        res *= 10;
        res += c - '0';
        c = get();
    } while (!isWhitespace(c) && c != '.');
    if (c == '.') {
        vi digits;
        c = get();
        do {
            if (!isdigit(c)) {
                error = UNEXPECTED_SYMBOL;
                return 0;
            }
            digits.push_back(c - '0');
            c = get();
        } while (!isWhitespace(c));
        double add = 0;
        for (int i = int(digits.size()) - 1; i >= 0; i--) {
            add += digits[i];
            add /= 10;
        }
        res += add;
    }
    return res * sgn;
}

template<>
int Input::readType() {
    return readInteger<int>();
}

template<>
ll Input::readType() {
    return readInteger<ll>();
}

template<>
char Input::readType() {
    error = OK;
    int c = skipWhitespace();
    if (error != OK) {
        return 0;
    }
    return c;
}

template<>
string Input::readType() {
    error = OK;
    int c = skipWhitespace();
    if (error != OK) {
        return "";
    }
    vector<char> res;
    do {
        if (error != OK) {
            return "";
        }
        res.push_back(c);
    } while (!isWhitespace(c = get()));
    return string(res.begin(), res.end());
}

inline int Input::readInt() {
    return readType<int>();
}

inline ll Input::readLong() {
    return readType<ll>();
}

string Input::readString() {
    return readType<string>();
}

double Input::readDouble() {
    return readType<double>();
}

#endif

#ifndef CPP_OUTPUT_H
#define CPP_OUTPUT_H



class Output {
private:
    ostream& out;
    template<typename T> void printSingle(const T& value);
    template<typename T> void printSingle(const vector<T>& value);
    template<typename T, typename U> void printSingle(const pair<T, U>& value);

public:
    Output(ostream& out);
    void print();
    template<typename T, typename...Targs>void print(const T& first, const Targs... args);
    template<typename...Targs>void printLine(const Targs... args);
};

Output::Output(ostream &out) : out(out) {
    out << setprecision(12);
}

void Output::print() {
}

template<typename T, typename... Targs>
void Output::print(const T& first, const Targs... args) {
    printSingle(first);
    if (sizeof...(args) != 0) {
        out << ' ';
        print(args...);
    }
}

template<typename T>
void Output::printSingle(const T& value) {
    out << value;
}

template<typename... Targs>
void Output::printLine(const Targs... args) {
    print(args...);
    out << '\n';
}

template<typename T>
void Output::printSingle(const vector<T>& array) {
    unsigned int size = array.size();
    for (int i = 0; i < size; ++i) {
        out << array[i];
        if (i + 1 != size) {
            out << ' ';
        }
    }
}

template<typename T, typename U>
void Output::printSingle(const pair<T, U>& value) {
    out << value.first << ' ' << value.second;
}

#endif

//
// Created by egor on 04.11.2019.
//

#ifndef JHELPER_EXAMPLE_PROJECT_GRAPH_H
#define JHELPER_EXAMPLE_PROJECT_GRAPH_H



template <typename W, typename C>
class WeightedFlowEdge {
private:
    WeightedFlowEdge<W, C>* reverseEdge;

public:
    const int from;
    const int to;
    W weight;
    C capacity;
    int id;

    WeightedFlowEdge(int from, int to, W weight, C capacity) : from(from), to(to), weight(weight), capacity(capacity) {
        reverseEdge = new WeightedFlowEdge(this);
    }

    WeightedFlowEdge<W, C>* transposed() { return nullptr; }
    WeightedFlowEdge<W, C>* reverse() { return reverseEdge; }
    void push(C flow) {
        capacity -= flow;
        reverseEdge->capacity += flow;
    }
    C flow() const {
        return reverseEdge->capacity;
    }

private:
    WeightedFlowEdge(WeightedFlowEdge<W, C>* reverse) : from(reverse->to), to(reverse->from), weight(-reverse->weight), capacity(0) {
        reverseEdge = reverse;
    }
};

template <typename C>
class FlowEdge {
private:
    FlowEdge<C>* reverseEdge;

public:
    const int from;
    const int to;
    C capacity;
    int id;

    FlowEdge(int from, int to, C capacity) : from(from), to(to), capacity(capacity) {
        reverseEdge = new FlowEdge(this);
    }

    FlowEdge<C>* transposed() { return nullptr; }
    FlowEdge<C>* reverse() { return reverseEdge; }
    void push(C flow) {
        capacity -= flow;
        reverseEdge->capacity += flow;
    }
    C flow() const {
        return reverseEdge->capacity;
    }

private:
    FlowEdge(FlowEdge<C>* reverse) : from(reverse->to), to(reverse->from), capacity(0) {
        reverseEdge = reverse;
    }
};

template <typename W>
class WeightedEdge {
public:
    const int from;
    const int to;
    W weight;
    int id;

    WeightedEdge(int from, int to, W weight) : from(from), to(to), weight(weight) {
    }

    WeightedEdge<W>* transposed() { return nullptr; }
    WeightedEdge<W>* reverse() { return nullptr; }
};

template <typename W>
class BidirectionalWeightedEdge {
private:
    BidirectionalWeightedEdge<W>* transposedEdge;

public:
    const int from;
    const int to;
    W weight;
    int id;

    BidirectionalWeightedEdge(int from, int to, W weight) : from(from), to(to), weight(weight) {
        transposedEdge = new BidirectionalWeightedEdge(this);
    }

    BidirectionalWeightedEdge<W>* transposed() { return transposedEdge; }
    BidirectionalWeightedEdge<W>* reverse() { return nullptr; }

private:
    BidirectionalWeightedEdge(BidirectionalWeightedEdge<W>* transposed) : from(transposed->to), to(transposed->from), weight(transposed->weight) {
        transposedEdge = transposed;
    }
};

class SimpleEdge {
public:
    const int from;
    const int to;
    int id;

    SimpleEdge(int from, int to) : from(from), to(to) {
    }

    SimpleEdge* transposed() { return nullptr; }
    SimpleEdge* reverse() { return nullptr; }
};

class BidirectionalEdge {
private:
    BidirectionalEdge* transposedEdge;

public:
    const int from;
    const int to;
    int id;

    BidirectionalEdge(int from, int to) : from(from), to(to) {
        transposedEdge = new BidirectionalEdge(this);
    }

    BidirectionalEdge* transposed() { return transposedEdge; }
    BidirectionalEdge* reverse() { return nullptr; }

private:
    BidirectionalEdge(BidirectionalEdge* transposed) : from(transposed->to), to(transposed->from) {
        transposedEdge = transposed;
    }
};

template <class Edge>
class Graph {
public:
    int vertexCount;
    int edgeCount = 0;
    vector<vector<Edge*> > edges;

    Graph(int vertexCount) : vertexCount(vertexCount) {
        edges.resize(vertexCount);
    }

    void addEdge(Edge* edge) {
        edge->id = edgeCount;
        edges[edge->from].push_back(edge);
        if (edge->reverse() != nullptr) {
            edge->reverse()->id = edgeCount;
            edges[edge->reverse()->from].push_back(edge->reverse());
        }
        if (edge->transposed() != nullptr) {
            edges[edge->transposed()->from].push_back(edge->transposed());
            edge->transposed()->id = edgeCount;
            if (edge->transposed()->reverse() != nullptr) {
                edges[edge->transposed()->reverse()->from].push_back(edge->transposed()->reverse());
                edge->transposed()->reverse()->id = edgeCount;
            }
        }
        edgeCount++;
    }
};

typedef FlowEdge<ll> LongFlowEdge;
typedef WeightedEdge<ll> LongWeightedEdge;
typedef FlowEdge<int> IntFlowEdge;
typedef WeightedEdge<int> IntWeightedEdge;
typedef BidirectionalWeightedEdge<ll> LongBiWeightedEdge;
typedef BidirectionalWeightedEdge<int> IntBiWeightedEdge;

#endif //JHELPER_EXAMPLE_PROJECT_GRAPH_H


//#pragma comment(linker, "/STACK:200000000")

vector<ll> val;

class Predicate {
public:
    bool operator()(int a, int b) const {
        if (val[a] != val[b]) {
            return val[a] > val[b];
        }
        return a < b;
    }
};

class TollCharges {
public:
	void solve(istream& inp, ostream& outp) {
        Input in(inp);
        Output out(outp);

        int n = in.readInt();
        int k = in.readInt();
        vi x, y, a, b;
        in.readArrays(n - 1, x, y, a, b);
        decreaseByOne(x, y);
        if (k == n - 1) {
            out.printLine(0);
            return;
        }
        Graph<IntWeightedEdge> graph(n);
        for (int i = 0; i < n - 1; ++i) {
            graph.addEdge(new IntWeightedEdge(x[i], y[i], b[i]));
            graph.addEdge(new IntWeightedEdge(y[i], x[i], a[i]));
        }
        val.resize(2 * n - 2);
        set<int, Predicate> all;
        vi qty(n);
        function<void(int, int)> dfs = [&](int vertex, int last) -> void {
            qty[vertex] = 1;
            for (auto edge : graph.edges[vertex]) {
                if (edge->to == last) {
                    continue;
                }
                dfs(edge->to, vertex);
                qty[vertex] += qty[edge->to];
                val[edge->id] = ll(qty[edge->to]) * edge->weight;
                all.insert(edge->id);
            }
        };
        dfs(0, -1);
        auto it = all.begin();
        ll sum = 0;
        for (int i : all) {
            sum += val[i];
        }
        set<int, Predicate> best;
        for (auto i = 0; i < k; i++) {
            sum -= val[*it];
            best.insert(*it);
            it++;
        }
        ll answer = sum;
        auto remove = [&](int id) {
            all.erase(id);
            sum -= val[id];
            if (best.count(id) == 1) {
                best.erase(id);
                sum += val[id];
                auto it = all.begin();
                if (!best.empty()) {
                    it = all.lower_bound(*best.rbegin());
                    it++;
                }
                best.insert(*it);
                sum -= val[*it];
            }
        };
        Predicate predicate;
        auto add = [&](int id) {
            all.insert(id);
            sum += val[id];
            if (!best.empty() && predicate(id, *best.rbegin())) {
                sum += val[*best.rbegin()];
                best.erase(*best.rbegin());
                best.insert(id);
                sum -= val[id];
            }
        };
        function<void(int, int)> dfs2 = [&](int vertex, int last) -> void {
            int eId = -1;
            if (last != -1) {
                for (auto edge : graph.edges[vertex]) {
                    if (edge->to == last) {
                        eId = edge->id;
                        val[edge->id] = ll(edge->weight) * (n - qty[vertex]);
                        add(edge->id);
                        break;
                    }
                }
            }
            minim(answer, sum);
            for (auto edge : graph.edges[vertex]) {
                if (edge->to == last) {
                    continue;
                }
                remove(edge->id);
                dfs2(edge->to, vertex);
                add(edge->id);
            }
            if (eId != -1) {
                remove(eId);
            }
        };
        dfs2(0, -1);
        out.printLine(answer);
	}
};


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
	TollCharges solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	int n;
in >> n;
for(int i = 0; i < n; ++i) {
	solver.solve(in, out);
}

	return 0;
}
